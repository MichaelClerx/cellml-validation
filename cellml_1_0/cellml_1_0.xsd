<?xml version="1.0" encoding="iso-8859-1"?>
<xs:schema
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:cellml="http://www.cellml.org/cellml/1.0#"
    targetNamespace="http://www.cellml.org/cellml/1.0#"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified">
   <xs:annotation>
    <xs:documentation>
This schema document provides partial validation of CellML 1.0 documents.

Notes:

 - Unlike the spec, this schema places an additional restriction on cellml
   identifiers, insisting that they do not start with a numerical character. As
   a result, expressions such as 1e12 are valid according to the spec, but do
   not pass validation with this schema.

    TODO: Just to what the spec says

Limitations related to model structure:

 - The schema does not detect variables with both public and private interface
   set to "in" (see CellML 1.0, 3.4.3.6).

 - The schema does not detect variables with both an initial value and a
   (public or private) interface set to "in" (see CellML 1.0, 3.4.3.8).

 - The schema does not detect when a `map_components` lists the same component
   as `component_1` and `component_2` (see CellML 1.0, 3.4.5.4). This can be
   done with elements in XML Schema, but not with attributes.

 - The schema can not detect duplicate connections when connection_1 in one
   connection equals connection_2 in the other.

 - The schema does not detect when a `map_variables` violates the rules for
   public and private interfaces (see CellML 1.0, 3.4.6.4).

 - The schema does not detect when a `map_variables` is defined for variables
   with incompatible units.

Limitations related to maths:

 - Rules regarding to maths are not validated by this schema. For example, the
   schema does not detect if MathML `ci` elements name existing variables
   (CellML 1.0, 4.4.2), if `cn` elements have valid `cellml:units` attributes
   (CellML 1.0, 4.4.3), or if the maths in a component defines values for
   variables not owned by the component (CellML 1.0, 4.4.4).

 - The schema does not check if MathML is limited to the "CellML subset" (for
   "valid CellML subset documents") or even if MathML is limited to content
   MathML (for "valid CellML documents"; see CellML 1.0, section 4.2.3).

    TODO: This could be implemented by creating a schema containing only
          content MathML definitions.

Limitations related to units:

 - The schema does not check if `units` attributes point to a valid unit. A
   valid unit is either a local unit (which could be implemented with a key and
   keyref) or one of a list of standard units (which could be implemented with
   a string and enumeration), there is no way of simultaneously allowing both
   in an XML schema.

 - The schema does not detect when a `units` with `base_units="yes"` includes
   a `unit` element (disallowed by CellML 1.0, 5.4.1.1).

 - The schema does not detect when a `units` name overlaps with a predefined
   unit from CellML 1.0 table 2.

 - The schema does not detect when a `units` element contains multiple `unit`
   elements, one of which defines a non-zero offset (CellML 1.0, 5.4.2.7).

 - The schema does not detect when a `unit` element with a non-zero offset has
   an exponent other than "1.0" (CellML 1.0, 5.4.2.7).


GOT UP TO BUT NOT INCLUDING 5.5




 - More!

Limitations related to extensions and namespaces:

 - CellML 1.0 states that "attributes without an explicit prefix declaration
   are assumed to be in the same namespace as their parent element". This
   changes the rules of XML (which says that attributes without a prefix are
   never in a namespace), and so cannot be implemented with XML compliant
   technology e.g. schemas.

 - CellML 1.0 defines "extension elements" and "extension attributes" as
   elements and attributes that are not in the following namespaces:

   - CellML "http://www.cellml.org/cellml/1.0#" cellml
   - CellML Metadata "http://www.cellml.org/metadata/1.0#" cmeta
   - MathML "http://www.w3.org/1998/Math/MathML" mathml
   -  RDF "http://www.w3.org/1999/02/22-rdf-syntax-ns#"rdf

   Note that following this rule strictly, all the attributes found in
   cellml elements (which have no namespace, see above) are extension
   attributes. In this schema, we instead assume that unnamespaced attributes
   defined in the cellml spec are not extension attributes.

 - Extension elements and attributes are allowed everywhere: "Although not
   explicitly stated throughout this specification, a document author may add
   extension elements and extension attributes to any CellML element in a
   CellML document without affecting the validity of the document." (CellML
   1.0, 2.4.3). This rule cannot be implemented using Schema `any` and
   `anyAttribute` elemements, because they allow whitelisting namespaces, but
   not blacklisting them. The only way to implement this rule then, is to use
   the `##other` qualifier, which selects all namespaces except the target
   namespace (CellML) - including RDF, MathML and CellML Metadata.

 - Using `any` with `##other` introduces a new problem for `mathml:math`
   elements: because these are matched both by a `element ref="mathml:math` and
   by `any namespace="##other" the schema becomes non-deterministic (according
   to the rules of Schema 1.0) and no longer validates. As a result, we have to
   handle the `mathml` elements using the `any` selector. To still get MathML
   validation therefore, we set the `processing` attribute of `any` to "lax".
   This means that MathML will be validated if the schema can be found, but no
   error will be raised if the schema cannot be found.

 - Using `anyAttribute` with `##other` allows all attributes from cmeta, so
   this schema cannot check that only the `cmeta:id` attribute is used.

 - CellML 1.0 states that "For interoperability, elements in the CellML
   namespace should not be defined inside extension elements" (CellML 1.0,
   2.4.3). This schema does not validate the contents of any extension
   elements, and so this rule cannot be implemented.

    </xs:documentation>
  </xs:annotation>

  <!-- External schemas for MathML, RDF, and cmeta:id, used in lax validation -->
  <xs:import namespace="http://www.w3.org/1998/Math/MathML"
             schemaLocation="http://www.w3.org/Math/XMLSchema/mathml2/mathml2.xsd" />
  <xs:import namespace="http://www.cellml.org/metadata/1.0#"
             schemaLocation="http://cellml.org/specifications/xsd/cmeta-id.xsd" />

  <!-- CellML Identifiers -->
  <xs:simpleType name="identifier">
    <xs:restriction base="xs:string">
      <xs:pattern value="(_[0-9_]*)?[a-zA-Z][a-zA-Z0-9_]*" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Type for real number strings -->
  <!-- We could use `double` for this, but there is no number type defined in CellML -->
  <xs:simpleType name="real_number">
    <xs:restriction base="xs:string">
      <xs:pattern value="[+-]?((\.[0-9]+)|([0-9]+\.?[0-9]*))([eE][+-]?[0-9]+)?" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Type for attributes having either "yes" or "no" as value -->
  <xs:simpleType name="yes_no">
    <xs:restriction base="xs:string">
      <xs:enumeration value="yes" />
      <xs:enumeration value="no" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Model element -->
  <xs:element name="model" type="cellml:model_type">
    <!-- Model keys -->
    <!-- Unique component names -->
    <xs:key name="component_name">
      <xs:selector xpath="component" />
      <xs:field xpath="@name" />
    </xs:key>
    <!-- Unique model units names -->
    <xs:unique name="units_name">
      <xs:selector xpath="units" />
      <xs:field xpath="@name" />
    </xs:unique>
    <!-- Component connections must name components -->
    <xs:keyref name="connect_component_1" refer="cellml:component_name">
      <xs:selector xpath="connection/map_components" />
      <xs:field xpath="@component_1" />
    </xs:keyref>
    <xs:keyref name="connect_component_2" refer="cellml:component_name">
      <xs:selector xpath="connection/map_components" />
      <xs:field xpath="@component_2" />
    </xs:keyref>
    <!-- Groups must name components -->
    <xs:keyref name="group_components" refer="cellml:component_name">
      <xs:selector xpath="group/component_ref" />
      <xs:field xpath="@component" />
    </xs:keyref>
  </xs:element>

  <!-- Model type and component keys/keyrefs -->
  <xs:complexType name="model_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="units" type="cellml:units_type" />
      <xs:element name="component" type="cellml:component_type">
        <!-- Component keys -->
        <!-- Unique variable names within component -->
        <xs:key name="variable_name">
          <xs:selector xpath="variable" />
          <xs:field xpath="@name" />
        </xs:key>
        <!-- Unique reaction variable names within component -->
        <xs:keyref name="reaction_variables" refer="cellml:variable_name">
          <xs:selector xpath="reaction/variable_ref" />
          <xs:field xpath="@variable" />
        </xs:keyref>
        <xs:keyref name="delta_variables" refer="cellml:variable_name">
          <xs:selector xpath="reaction/variable_ref/role" />
          <xs:field xpath="@delta_variable" />
        </xs:keyref>
        <!-- Unique component units names -->
        <!-- Note: This is not a key, since the unit fields can refer to either
             a model or component unit, or a predefined base unit. -->
        <xs:unique name="component_units_name">
          <xs:selector xpath="units" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:element name="group" type="cellml:group_type" />
      <xs:element name="connection" type="cellml:connection_type">
        <!-- Component connections must be unique (partial check) -->
        <xs:unique name="unique_connections">
          <xs:selector xpath="connection/map_components" />
          <xs:field xpath="component_1" />
          <xs:field xpath="component_2" />
        </xs:unique>
      </xs:element>
      <!-- Allow any elements not in CellML (including tmp-documentation and rdf) -->
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="name" type="cellml:identifier" use="required" />
    <!-- Allow any attributes not in CellML (including cmeta:id) -->
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <!-- Component type -->
  <xs:complexType name="component_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="units" type="cellml:units_type" />
      <xs:element name="variable" type="cellml:variable_type" />
      <xs:element name="reaction" type="cellml:reaction_type">
        <!-- Reaction keys -->
        <xs:unique name="reaction_variable">
          <xs:selector xpath="variable_ref" />
          <xs:field xpath="@variable" />
        </xs:unique>
        <xs:unique name="delta_variable">
          <xs:selector xpath="role" />
          <xs:field xpath="@delta_variable" />
        </xs:unique>
      </xs:element>
      <!-- Allow elements from other namespaces, including MathML. Use lax
           processing so that MathML might still be validated. -->
      <xs:any namespace="##other" processContents="lax" />
    </xs:choice>
    <xs:attribute name="name" type="cellml:identifier" use="required" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <!-- Variable type -->
  <xs:complexType name="variable_type">
    <xs:choice minOccurs="0">
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="name" type="cellml:identifier" use="required" />
    <xs:attribute name="units" type="xs:string" use="required" />
    <xs:attribute name="initial_value" type="cellml:real_number" use="optional" />
    <xs:attribute name="public_interface" type="cellml:interface" use="optional" default="none" />
    <xs:attribute name="private_interface" type="cellml:interface" use="optional" default="none" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:simpleType name="interface">
    <xs:restriction base="xs:string">
      <xs:enumeration value="in" />
      <xs:enumeration value="out" />
      <xs:enumeration value="none" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Connection and mapping types -->
  <xs:complexType name="connection_type">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="map_components" type="cellml:map_components_type" minOccurs="1" maxOccurs="1">
        <!--
        <xs:unique name="component_1_is_not_component_2">
          <xs:selector xpath="." />
          <xs:field xpath="@component_1|@component_2" />
        </xs:unique>
        -->
      </xs:element>
      <xs:element name="map_variables" type="cellml:map_variables_type" minOccurs="1" maxOccurs="unbounded">
      </xs:element>
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="map_components_type">
    <xs:choice minOccurs="0">
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="component_1" type="cellml:identifier" use="required" />
    <xs:attribute name="component_2" type="cellml:identifier" use="required" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="map_variables_type">
    <xs:choice minOccurs="0">
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="variable_1" type="cellml:identifier" use="required" />
    <xs:attribute name="variable_2" type="cellml:identifier" use="required" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <!-- Unit types -->
  <xs:complexType name="units_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="unit" type="cellml:unit_type" />
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="name" type="cellml:identifier" use="required" />
    <xs:attribute name="base_units" type="cellml:yes_no" use="optional" default="no" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="unit_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="units" type="xs:string" use="required" />
    <xs:attribute name="prefix" type="cellml:unit_prefix" use="optional" default="0" />
    <xs:attribute name="exponent" type="cellml:real_number" use="optional" default="1.0" />
    <xs:attribute name="multiplier" type="cellml:real_number" use="optional" default="1.0" />
    <xs:attribute name="offset" type="cellml:real_number" use="optional" default="0.0" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:simpleType name="unit_prefix">
    <xs:union memberTypes="cellml:unit_prefix_string xs:integer" />
  </xs:simpleType>

  <xs:simpleType name="unit_prefix_string">
    <xs:restriction base="xs:string">
      <xs:enumeration value="yotta" />
      <xs:enumeration value="zetta" />
      <xs:enumeration value="exa" />
      <xs:enumeration value="peta" />
      <xs:enumeration value="tera" />
      <xs:enumeration value="giga" />
      <xs:enumeration value="mega" />
      <xs:enumeration value="kilo" />
      <xs:enumeration value="hecta" />
      <xs:enumeration value="deka" />
      <xs:enumeration value="deci" />
      <xs:enumeration value="centi" />
      <xs:enumeration value="milli" />
      <xs:enumeration value="micro" />
      <xs:enumeration value="nano" />
      <xs:enumeration value="pico" />
      <xs:enumeration value="femto" />
      <xs:enumeration value="atto" />
      <xs:enumeration value="zepto" />
      <xs:enumeration value="yocto" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Group and relationship types -->
  <xs:complexType name="group_type">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="relationship_ref" type="cellml:relationship_ref_type" minOccurs="1" />
      <xs:element name="component_ref" type="cellml:component_ref_type" minOccurs="1" />
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="relationship_ref_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="relationship" type="cellml:relationship" use="required" />
    <xs:attribute name="name" type="cellml:identifier" use="optional" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="component_ref_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="component_ref" type="cellml:component_ref_type" />
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="component" type="xs:string" use="required" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:simpleType name="relationship">
    <xs:restriction base="xs:string">
      <xs:enumeration value="containment" />
      <xs:enumeration value="encapsulation" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Reaction types -->
  <xs:complexType name="reaction_type">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="variable_ref" type="cellml:variable_ref_type" minOccurs="1" />
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="reversible" type="cellml:yes_no" use="optional" default="yes" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="variable_ref_type">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="role" type="cellml:role_type" minOccurs="1" />
      <xs:any namespace="##other" processContents="skip" />
    </xs:choice>
    <xs:attribute name="variable" type="xs:string" use="required" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="role_type">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <!-- Use lax processing for MathML validation -->
      <xs:any namespace="##other" processContents="lax" />
    </xs:choice>
    <xs:attribute name="role" type="cellml:species_role" use="required" />
    <xs:attribute name="direction" type="cellml:reaction_direction" use="optional" default="forward" />
    <xs:attribute name="delta_variable" type="xs:string" use="optional" />
    <xs:attribute name="stoichiometry" type="xs:double" use="optional" />
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:simpleType name="species_role">
    <xs:restriction base="xs:string">
      <xs:enumeration value="reactant" />
      <xs:enumeration value="product" />
      <xs:enumeration value="activator" />
      <xs:enumeration value="catalyst" />
      <xs:enumeration value="inhibitor" />
      <xs:enumeration value="modifier" />
      <xs:enumeration value="rate" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="reaction_direction">
    <xs:restriction base="xs:string">
      <xs:enumeration value="forward" />
      <xs:enumeration value="backward" />
      <xs:enumeration value="both" />
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
